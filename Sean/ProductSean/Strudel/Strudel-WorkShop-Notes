WORKSHOP // Coding Music With Strudel // Dan Gorelick and Viola He : https://www.youtube.com/watch?v=oqyAJ4WeKoU
s("sd bd cp") # 's' is short for 'sound' 'sd' = snare drum, 'bd' = base drum, cp = clap
s("bd hh sd hh") # in strudel only the last 'block' will play unless you add a ',' like below but it highlights what is playing so you know
  stack(
    s("<bd bd*2> ~"),
    s("~ sd"),
    s("~ cp ~ cp"),
    s("hhx8?"),
  ) 
on the right hand side tabs click the 'sounds' tab, and you can see all the built in sounds that strudel has, just click them
  each sound will have a number like 'sound(#)' the '#' is how many sounds, so you can select through it for 'jazz(8)' has 8 sounds, so you can go through 1-8 with 'jazz:1'
on the right hand side tabs click the 'reference' tab to get a list of all the functions you can use to alter the sounds
  stack (
  s("jazz <~ jazz> ~ <[~ jazz] ~>"),
  s("cp hh sd hh")) 
# theres 2 types of brackets '[]' = divide a beat '<>' = a selection, if you have 2 things in the angle brackets, it will cycle through them 1 by 1 
'.slow(2)' # 'slow(2)' will slow down the beat by half
'.struct' # allows you to use 1's and 0'z to show when it plays
's("jazz").struct("1 0 0 [0 1] 1 1 0 0").slow(2)' # 'struct' is a new key word where you can use '1's and '0's instead of writing out 'jazz' for each note
's("<jazz [cp sd]>").struct("1 0 0 [0 1] 1 1 0 0").slow(2)' # you can use the '<>' and '[]' anywhere, this will play 'jazz' half the time with a clap(first part) and snaredrum(second part)
'.mask' # new keyword that will alow you to limit when it plays 'on or off' not changing the tempo
's("cp hh sd hh").mask("<0 1>")' # will play every other cycle
's("cp hh sd hh").mask("<0 1>/2")' # will play 2 bars then turn off for 2 bars, if you replace '2' with 8, will do 8 cycles with and 8 without
in Strudel you don't need to abide to standard musical theory like octaves, it's helpful though, you should know what all notes and chords are (c note, g minor/major, chord, etc)
    setcps(100/120)
    stack(
      s("bd").lpf(500),
      s("~ sd"),
      s("hh hh hh hh").gain(0.5),
      "{0 1 2 3 4 5 6 7 8 9 1 0 2 3 4 5}%4"
        .scale('c4 minor').note().sound("square").cutoff(1500),
      "{0 1 2 3 4 5 6 7 8 9 1 0 2 3 4 }%4"
        .scale('c3 minor').note().sound("square").cutoff(1500).legato(0.5),
      "<0 1 2 3>"
        .struct("1(<3 5>,8),8")
        .scale('c3 minor').note().sound("square").cutoff(2000).legato(0.5),
    )
'setcps(100/120)' # this is the bpm = beats per minute
'.lpf(500)' # low pass filter
s("hh hh hh hh").gain(0.9), # .gain reduces the volume
'"0 1 2 3".scale('c minor').note()' # 
'"{0 1 2 3 4 5 6 7 8 9 1 0 2 3 4 5}%4".scale('c4 minor')' # the '{}%4' will divide the cycle into 4 phases
  # if you copy above and remove one of the notes, and change it to a 'c3 minor'(or whatever) it will have them slightly out of sync but similar pattern  
'.sound("square")' #
'.cutoff(1500) # 1500 hertz cutoff
 "<0 1 2 3>".struct("1(3,8)") # euclidean rhythyms : 
"<0 1 2 3>".struct("1(3,8),8") # euclidean rhythyms offset : 
"<0 1 2 3>".struct("1(<3 5>,8),8") # euclidean rhythyms offset with swap : 





























