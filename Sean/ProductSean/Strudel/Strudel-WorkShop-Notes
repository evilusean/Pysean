WORKSHOP // Coding Music With Strudel // Dan Gorelick and Viola He : https://www.youtube.com/watch?v=oqyAJ4WeKoU
s("sd bd cp") # 's' is short for 'sound' 'sd' = snare drum, 'bd' = base drum, cp = clap
s("bd hh sd hh") # in strudel only the last 'block' will play unless you add a ',' like below but it highlights what is playing so you know
  stack(
    s("<bd bd*2> ~"),
    s("~ sd"),
    s("~ cp ~ cp"),
    s("hhx8?"),
  ) 
on the right hand side tabs click the 'sounds' tab, and you can see all the built in sounds that strudel has, just click them
  each sound will have a number like 'sound(#)' the '#' is how many sounds, so you can select through it for 'jazz(8)' has 8 sounds, so you can go through 1-8 with 'jazz:1'
on the right hand side tabs click the 'reference' tab to get a list of all the functions you can use to alter the sounds
  stack (
  s("jazz <~ jazz> ~ <[~ jazz] ~>"),
  s("cp hh sd hh")) 
# theres 2 types of brackets '[]' = divide a beat '<>' = a selection, if you have 2 things in the angle brackets, it will cycle through them 1 by 1 
'.slow(2)' # 'slow(2)' will slow down the beat by half
'.struct' # allows you to use 1's and 0'z to show when it plays
's("jazz").struct("1 0 0 [0 1] 1 1 0 0").slow(2)' # 'struct' is a new key word where you can use '1's and '0's instead of writing out 'jazz' for each note
's("<jazz [cp sd]>").struct("1 0 0 [0 1] 1 1 0 0").slow(2)' # you can use the '<>' and '[]' anywhere, this will play 'jazz' half the time with a clap(first part) and snaredrum(second part)
'.mask' # new keyword that will alow you to limit when it plays 'on or off' not changing the tempo
's("cp hh sd hh").mask("<0 1>")' # will play every other cycle
's("cp hh sd hh").mask("<0 1>/2")' # will play 2 bars then turn off for 2 bars, if you replace '2' with 8, will do 8 cycles with and 8 without
in Strudel you don't need to abide to standard musical theory like octaves, it's helpful though, you should know what all notes and chords are (c note, g minor/major, chord, etc)
  setcps(100/120) // Sets the global tempo to 100 BPM. The division by 120 sets one cycle to 1.2 seconds.
  stack( // Plays all the following patterns simultaneously (layers them).
    // Drum Track 1: Kick Drum (The Low End)
    s("bd").lpf(500), // Plays a Bass Drum ("bd") once per cycle and applies a Low-Pass Filter (lpf) at 500 Hz for a deep, sub-heavy sound.
    // Drum Track 2: Snare Drum (The Backbeat)
    s("~ sd"), // "~" is a rest for the first half of the cycle, and "sd" (snare drum) plays in the second half, creating a classic two-beat backbeat.
    // Drum Track 3: Hi-Hats (Rhythm Texture)
    s("hh hh hh hh").gain(0.5), // Plays a Closed Hi-Hat ("hh") four times per cycle (quarter-note rhythm). .gain(0.5) sets the volume to 50%.
    // Melodic Track 1: High Register Lead
    "{0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15}%4" // A 16-step pitch sequence. The chop operator (%4) plays only 4 steps per cycle, making the sequence take 4 cycles (bars) to complete.
      .scale('c4 minor').note().sound("square").cutoff(1500), // Uses the C minor scale in the 4th octave. Tone is a square wave synth with a filter cutoff at 1500 Hz.
    // Melodic Track 2: Lower Register Harmony
    "{0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 }%4" // A 15-step pitch sequence that will fall subtly out of sync with the 16-step lead. %4 ensures 4 steps are played per cycle.
      .scale('c3 minor').note().sound("square").cutoff(1500).legato(0.5), 
      // Uses the C minor scale in the 3rd octave. Same square wave tone and filter. .legato(0.5) makes the notes staccato (choppy).
    // Melodic Track 3: Rhythmic Modulation (Euclidean)
    "<0 1 2 3>" // The source notes for the rhythmic structure.
      .struct("1(<3 5>,8),8") // Applies a complex Euclidean rhythm on 8 steps: 3 pulses in the first cycle, then 5 pulses in the next. The ",8" adds an 8-step offset (syncopation).
      .scale('c3 minor').note().sound("square").cutoff(2000).legato(0.5), // C minor, 3rd octave, square wave. Brighter filter cutoff at 2000 Hz, with staccato notes.
  )
setcpm(100/4) # Sets the tempo to 100 BPM where one cycle equals one 4-beat bar.
.lpf(500) # Applies a Low Pass Filter, cutting out frequencies above 500 Hz.
s("hh hh hh hh").gain(0.9) # Plays the closed hi-hat four times and sets its volume to 90%.
note("0 1 2 3").scale('c minor') # Plays notes based on the indices of the C minor scale.
note("{0 ... 15}%4").scale('c4 minor') # Plays a 16-step pitch sequence but uses the chop operator (%4) to resolve only 4 steps per cycle.
.sound("square") # Changes the instrument's waveform to a square wave synthesizer sound.
.cutoff(1500) # Sets the frequency limit of the active filter to 1500 Hertz.
"<0 1 2 3>".struct("1(3,8)") # Generates a Euclidean rhythm that plays 3 events evenly across 8 steps.
"<0 1 2 3>".struct("1(3,8),8") # Applies the Euclidean rhythm with an offset of 8 steps, shifting the phrase's start time.
"<0 1 2 3>".struct("1(<3 5>,8),8") # Applies the Euclidean rhythm with an alternating pulse pattern (3 then 5) across bars, plus an 8-step offset.
Tangent : What is a Euclidean Rhythym? (not B! Elements) https://en.wikipedia.org/wiki/Euclidean_rhythm: 
  A Euclidean rhythm is a musical pattern created by distributing a certain number of events (or "pulses") as equally as possible within a given total number of steps.
  This method generates rhythms found across many cultures, such as the clave patterns in Afro-Cuban music or certain traditional drum rhythms from the Middle East.
  The algorithm for generating these rhythms was discovered by computer scientist Godfried Toussaint, who linked them to Euclid's algorithm for finding the greatest common divisor.
  In Strudel, you use the .struct() function along with a specific syntax to generate Euclidean rhythms.
  The basic syntax inside the .struct() function is a pattern string with two key parts: '1(P, E)'.
  Syntax Part	Strudel Meaning	Musical Meaning
  '1(...)'	Represents the event being played.	What sound or note is triggered.
  'P'	The first number inside the parentheses.	Pulses (P): The number of times the event will occur.
  'E'	The second number inside the parentheses.	Euclidean Steps (E): The total number of available steps in the pattern.
  '1(P,E),O' # 'O' = offset, offsets the pattern by the number in 'O'
  's("bd").struct("1(3,8)")' // Plays 3 events as evenly as possible over 8 steps. 
  You typically use .struct() to apply a rhythm to a source pattern, which is usually enclosed in angle brackets (<>).
  'note("<c e g b>").scale("c major").struct("1(5,12)").sound("sine")' // Source Pattern: Four notes // Rhythm: 5 pulses over 12 steps
  1. Offset/Rotation (The ',O' after the pattern) You can shift the start point of the rhythm using a comma followed by the number of steps to offset '(O)'.
  s("cp").struct("1(3,8),4") // Note the ",4" // The same 3 pulses over 8 steps, but rotated 4 steps forward.
  's("snare").struct("1(<3 5>, 8)")' // In the first bar, the rhythm uses 3 pulses. // In the second bar, it uses 5 pulses. // Then it repeats.
if you don't put the beat in '<>' angle brackets for a Euclid like '"<0 1 2 3>".struct("1(<3 5>,8),8")', it will skip over notes, instead of just doing timing
  It will only hit the '3/8' or '5/8' notes with out '<>' carrot brackets '"0 1 2 3 4 5 6 7".struct("1(<3 5>,8),8")',
  think of it like a pizza, each cycle is a pizza, with this you are dividing the pizza, with this you are playing through 8 equal parts, and selecting the '3' and '5'th slices
  without the '<>' brackets you are playing ALL the notes in one cycle, with the '<>' brackets you are playing ONLY ONE per cycle, so it only hits the timing on that ONE note
'Shuffle' Sparkly Button - Top left to see what other people have built in strudel, 'Felix Roos', https://github.com/felixroos - wasn't there anymore when I checked... 
  The Community Bakery's shuffle functionality was disabled on June 11, 2025, due to a spam attack on Strudel's database.
  Users can no longer share shortened links or shuffle through user-generated patterns, although previously shared links will continue to work. 
  Strudel is investigating solutions to address this security issue and prevent future attacks.
.echoWith(pattern)	#Creates a rhythmic delay or echo effect where the delayed notes are also manipulated by the given pattern (e.g., changing their pitch or velocity).
.velocity(pattern)	#Sets the MIDI velocity (loudness/force) for each note in the pattern based on the provided numerical pattern.
.echo(pattern)	#Generates a standard delay or echo effect on the sound, where the delay time is controlled by the numerical or fractional pattern.
.clip(amount)	#Compresses the dynamic range of the pattern to prevent clipping distortion, effectively acting as a simple limiter/soft-clipper.
You can use functions to add transitions if you want to write a song instead of just a cycle, like below :
https://github.com/evilusean/Pysean/blob/main/Sean/ProductSean/Strudel/Algo-Rhythyms/3

























