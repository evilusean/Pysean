Started: 15Feb2023
Ended:
Page Leftoff: 27

Chapter 1: Introduction- Page 16-19====================================================================================================
Virtual Function(C)=A virtual function is a member function which is declared within a base class and is re-defined (overridden) by a derived class.
BST(Binary Search Tree)=Binary search trees allow binary search for fast lookup, addition, and removal of data items. Since the nodes in a BST are
  laid out so that each comparison skips about half of the remaining tree, the lookup performance is proportional to that of binary logarithm. 
  BSTs were devised in the 1960s for the problem of efficient storage
WhiteBoards=Used for coding interviews for the interviewee to explain their thought process/problem solving skills- Ask questions

II-Behind the Scenes-Page 20-26=========================================================================================================
Personal Interview -> Screening Interview -> Technical Interview
Ask interviewer coordinator their position in the company, the technical interview(coding+algo questions) will be done by an engineer
Some companies will give you homework, or use a synchronized code writing, or on paper and say it over phone, 
Relative Comparisons=You are being compared with the other interviewees, if the problem is hard for you, it is hard for them- its ok to get wrong
After interview if you don't hear back in 3-5 business days, check in politely with your interviewer in a week, or HR-they might be busy
If you fail an interview most will let you apply again in 6-12 months
Normally 3-6 interviews before an offer
Often your interview goes to a hiring commitee with your interviewers feedback where they will decide 'offer' 'more interviews' or 'rejectsean'
Be nice to your interviewer, they can fight for you to be hired or not
Explain your passion for technology, prepare answer, "Why do you want to work for us?" -Mention VS Code for Microsoft, etc
You will only reach the hiring manager if you've done well
Feedback is typically broken down into four categories (Analytical Ability, Coding,  Experience, and Communication) and you are given an 
  overall score from 1.0 to 4.0
If the hiring committee recommends an offer, your packet will go to a compensation committee and then to the executive management committee. 
  Returning a decision can take several weeks because there are so many stages and committees. 

III-Special Situations-Page 27-37 =========================================================================================================
SDETs =(software design engineers in test), PM=Product Manager ,Dev Lead and Managers
Visas and Work Authorization =Unfortunately, many smaller startups in the U.S. are not able to sponsor work visas. 
People without computer science degrees (or who earned their degrees a long time ago) should focus first on learning the core concepts discussed in this book,
  especially big O time, , binary search tree, breadth-first search, and other important concepts.
Most won't remember Dijkstra's algorithm or the specifics of how AVL trees works. 
Many candidates are poor at articulating their specific accomplishments. 
Not describing the details of the actions they took makes them a flawed candidate, but not necessarily a flawed employee. 
Being a good interview candidate is its own skill
At a very, very high level, there are four modes of questions;
  Sanity Check: These are often easy problem-solving or design questions. They assess a minimum 
    degree of competence in problem-solving. They won't tell distinguish between "okay" versus "great" so 
    don't evaluate them as such. You can use them earfy in the process (to filter out the worst candidates), or 
    when you only need a minimum degree of competency.
  Quality Check: These are the more challenging questions, often in problem-solving or design. They 
    are designed to be rigorous and really make a candidate think. Use these when algorithmic/problemsolving skiils are of high importance. 
    The biggest mistake people make here is asking questions that are, in fact, bad problem-solving questions. 
  Specialist Questions: These questions test knowledge of specific topics, such as Java or machine learning. . If it's easily acquirable,
    then there's no reason to hire for it.
  Proxy Knowledge: This is knowledge that is not quite at the specialist level (in fact, you might not even 
    need it), but that you would expect a candidate at their level to know For example, it might not be very 
    important to you if a candidate knows CSS or HTML. But if a candidate has worked in depth with these 
    technologies and can't talk about why tables are or aren't good, that suggests an issue. They're not 
    absorbing information core to their job.

IV-Before the Interview 38-43 =========================================================================================================
Without a great resume, there's no interview. And without great experience, there's no great resume.
Take the Big Project Classes: Seek out the classes with big coding projects. This is a great way to get somewhat practical experience before you have any 
  formal work experience. The more relevant the project is to the real world, the better. 
Get an Internship: Do everything you can to land an internship early in school. It will pave the way for even better internships before you graduate
Start Something: Build a project on your own time, participate in hackathons, or contribute to an open source project.
  It doesn't matter too much what it is. The important thing is that you're coding.
If you're trying to move from a lesser-known company to one of the "biggies," or from testing/IT into a dev role:
  Shift Work Responsibilities More Towards Coding: Without revealing to your manager that you are thinking  of leaving, you can discuss your eagerness to
    take on bigger coding challenges. As much as possible, try to ensure that these projects are "meaty," use relevant technologies, and lend themselves well
    to a resume bullet or two. It is these coding projects that will, ideally, form the bulk of your resume,
  Use Your Nights and Weekends: If you have some free time, use it to build a mobile app, a web app, or a piece of desktop software
Resume screeners look for the same things that interviewers do. They want to know that you're smart and that you can code.
  That means you should prepare your resume to highlight those two things
In the US, it is strongly advised to keep a resume to one page if you have less than ten years of experience. Shorter resumes are often more impressive. 
Recruiters only spend a fixed amount of time (about 10 seconds) looking at your resume. If you limit the content to the most impressive items, the 
  recruiter is sure to see them. Adding additional items just distracts the recruiter from what you'd really like them to see,
  Some people just flat-out refuse to read long resumes
Employment History: Your resume does not—and should not—include a full history of every role you've ever had. Include only the relevant positions—the 
  ones that make you a more impressive candidate.
Writing Strong Bullets:
  For each role, try to discuss your accomplishments with the following approach:"Accomplished X by implementing Y which led to Z." 
  "Reduced object rendering time by 75% by implementing distributed caching, leading to a 10% reduction in log-in time.
  "Increased average match accuracy from 1.2 to 1.5 by implementing a new comparison algorithm based on windiff."
  Not everything you did will fit intothis approach, butthe principle is the same: show what you did, how you did it, and what the results were.
    Ideally, you should try to make the results "measurable" somehow. 
Developing the projects section on your resume is often the best way to present yourself as more experienced
The projects should include your 2 - 4 most significant projects. State what the project was and which languages or technologies it employed
Be conservative about what software you list, and understand what's appropriate for the company. Software like Microsoft Office can almost always be cut.
  Technical software like Visual Studio and Eclipse is somewhat more relevant, but many of the top tech companies won't even care about that.
Languages: Should you list everything you've ever worked with, or shorten the list to just the ones that you're most comfortable with? 
  Listing everything you've ever worked with is dangerous. Many interviewers consider anything on your resume to be "fair game"as far as the interview.
  One alternative is to list most of the languages you've used, but add your experience level. This approach is shown below:
  Languages: Java (expert), C++ (proficient), JavaScript (prior experience). 
  Use whatever wording ("expert" "fluent" etc.) effectively communicates your skillset. 
  Some people list the number of years of experience they have with a particular language, but this can be really confusing. 
  If you first learned Java 10 years ago, and have used it occasionally throughout that time, how many years of experience is this?
  Some companies will throw out your resume just because of a typo.
For US positions, do not include age, marital status, or nationality. This sort of personal information is not appreciated by companies, as it creates 
  a legal liability for them. Vs Affirmative AxSean
Certifications: Certifications for software engineers can be anything from a positive, to a neutral, to a negative. This goes hand-in-hand with being too
  language focused; the companies that are biased against candidates with a very lengthy list of technologies tend to also be biased against certifications. 
  This means that in some cases, you should actually remove this Sort of experience from your resume. 
The languages in the cluster of {Python, Ruby, and JavaScript) are somewhat similar to each other. It's better if you can learn languages that are more
  different, like Python, C++, and Java. 
Page 42: Interview Prep guide

V-Behavioral Questions 44-49 =========================================================================================================
Behavioral questions are asked to get to know your personality
Go through each of the projects or components of your resume and ensure that you can talk about them in detail. Filling out a grid like this may help: 
  Columns=Challenges, Mistakes/Failures, Enjoyed, Leadership, Conflicts, What you would do differently
  Rows=Common Questions, Project 1, Project 2, Project 3, include any project, job, or activity included on resume
  Study this grid before your interview. Reducing each story to just a couple of keywords may make the grid easier to study and recall.
  you have one to three projects that you can talk about in detail. You should be able to discuss the technical components in depth.
When asked about your weaknesses, give a real weakness! A good answer conveys a real, legitimate weakness but emphasizes how you work to overcome it.
Most interviewers will give you a chance to ask them questions. The quality of your questions will be a factor, in their decisions.
  Genuine Questions: These are the questions you actually want to know the answers to
    "What is the ratio of testers to developers to program managers? What is the interaction like? How does project planning happen on the team?" 
  Insightful Questions: These questions demonstrate your knowledge or understanding of technology.
    "I noticed that you use technology X. How do you handle problem Y?
  Passion Questions: These questions are designed to demonstrate your passion for technology. They show that you're interested in learning and will be a 
    strong contributor to the company
    "I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this company to learn about this?" 
For those projects, and all your projects, be able to talk about the challenges, mistakes, technical decisions, choices of technologies 
  (and tradeoffs of these), and the things you would do differently.
Be Specific, Not Arrogant: Specificity means giving just the facts and letting the interviewer derive an interpretation
Limit Details: Stay tight on details and just state the key points. 
Nugget First: means starting your response with a "nugget" that succinctly describes what your response will be about.
  This technique grabs your interviewer's attention and makes it very ciear what your story will be about
S.A.R. (Situation, Action, Result): you start off outlining the situation, then explaining the actions you took, and lastly, describing the result.
Think about what your story says about you, What personality attributes has the candidate demonstrated?
So, tell me about yourself.... This is essentially a "pitch". It's your interviewer's first impression of you, so you want to be sure to nail this.
  A typical structure that works well for many people is essentially chronological, with the opening sentence describing their current job and the
  conclusion discussing their relevant and interesting hobbies outside of work (if any). 
  Current Role [Headline Only): "I'm a software engineer at Microworks, where I've been leading the Android team for the last five years." 
  College: 
  Post College & Onwards: 
  Current Role (Details): 
  Outside of Work: 
  Wrap Up: Example on page 49
Think carefully about your hobbies. You mayor may not want to discuss them. Often they're just fluff. If your hobby is just generic activities like skiing or 
  playing with your dog, you can probably skip it. Vs hobby is technical. Vs hobby demonstrates a positive personality attribute.
Sprinkle in Shows of Successes: (awards, promotions, being recruited out by someone you worked with, launches, etc.)

VI-BigO 50-71 =========================================================================================================
Big 0 time is the language and metric we use to describe the efficiency of algorithms. 
Time Complexity: This is what the concept of asymptotic runtime, or big 0 time, means.
0(1):0 (big O): In academia, big 0 describes an upper bound on the time. An algorithm that prints all the 
  values in an array could be described asO(N), but it could also be described as OfN^J.O^) , or 0(2 N) (or many other big 0 times). The algorithm is at least
  as fast as each of these; therefore they are upper bounds on the runtime. a simple  algorithm to print the values in an array isO(N) as well asO(M3) or any 
  runtime bigger than 0(N). 
0( log N): The total runtime is then a matter of how many steps (dividing N by 2 each time) we can take until N becomes 1. When you see a problem where the 
number of elements in the problem space gets halved each time, that will likely be a 0(log N) runtime.
0(N log N):
O(N):
O(N^):
0(2^N):
Q (big omega): In academia, 0 is the equivalent concept but for lower bound. Printing the values in an array is fl(N) as well as fi(log M) and Q(l).
After all, you know that it won't be faster than those runtimes. 
0 (big theta): In academia, 0 means both 0 and fi. That is, an algorithm is 0 (N) if it is both 0( N) and 0(N). 0 gives a tight bound on runtime.
You can also have multiple variables in your runtime.
Best Case: If all elements are equal, then quick sort will, on average, just traverse through the array once. This is 0(N).
Worst Case: What if we get really unlucky and the pivot is repeatedly the biggest element in the array? (Actually, this can easily happen. If the pivot is
  chosen to be the first element in the subarray and the array is sorted in reverse order, we'll have this situation.) In this case, our recursion doesn't 
  divide the array in half and recurse on each half. It just shrinks the subarray by one element. This will degenerate to an O(N^) runtime. 
Expected Case: Usually, though, these wonderful or terrible situations won't happen. Sure, sometimes the pivot will be very low or very high, but it won't 
  happen over and over again. We can expect a runtime  of 0( N log N). 
For many—probably most—algorithms, the worst case and the expected case are the same.
We rarely ever discuss best case time complexity, because it's not a very useful concept. After all, we could take essentially any algorithm, special case 
  some input, and then get an 0(1 ) time in the best case. 
Space Complexity: Time is not the only thing that matters in an algorithm. We might also care about the amount of memory— or space—required by an algorithm.
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require 0(n) space. If we need a 
  two-dimensional array of size nxn, this will require 0(n*) space. Stack space in recursive calls counts, too. Each of these calls is added to the call 
  stack and takes up actual memory.
  just because you have n calls total doesn't mean it takes O(n ) space. There will be roughly O(n) calls to pairSum. However, those calls do not exist 
  simultaneously on the call stack, so you only need 0(1) space. 
Drop the Constants: It is very possible for 0(N ) code to run faster than 0(1 ) code for specific inputs.
  For this reason, we drop the constants in runtime. An algorithm that one might have described as 0( 2N) is actuallyO(N).
  accept that it doesn't mean that 0(N) is always better than 0(N^).
Drop the Non-Dominant Terms: 0(N2+ N) becomesO(N^). 0(N2 + N) becomesO(N^).
Multi-Part Algorithms: Add vs. Multiply 
  If your algorithm is in the form "do this, then, when you're all done, do that" then you add the runtimes.
  If your algorithm is in the form "do this for each time you do that" then you multiply the runtimes.
  Count the iterations/runtimes, do they add or multiply?
Amortized Time:  It allows us to describe that, yes, this worst case happens every once in a while. But once it happens, it won't happen again for so 
  long that the cost is "a moritized."
Big 0 time is a difficult concept at first. Once it "clicks," it gets fairly easy. The same patterns come up again and again, and the rest you can derive. 
Examples on page 58-69, Solutions on page 70.
















