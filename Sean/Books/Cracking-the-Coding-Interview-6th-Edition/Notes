Started: 15Feb2023
Ended:
Page Leftoff: 27

Chapter 1: Introduction- Page 16-19====================================================================================================
Virtual Function(C)=A virtual function is a member function which is declared within a base class and is re-defined (overridden) by a derived class.
BST(Binary Search Tree)=Binary search trees allow binary search for fast lookup, addition, and removal of data items. Since the nodes in a BST are
  laid out so that each comparison skips about half of the remaining tree, the lookup performance is proportional to that of binary logarithm. 
  BSTs were devised in the 1960s for the problem of efficient storage
WhiteBoards=Used for coding interviews for the interviewee to explain their thought process/problem solving skills- Ask questions

II-Behind the Scenes-Page 20-26=========================================================================================================
Personal Interview -> Screening Interview -> Technical Interview
Ask interviewer coordinator their position in the company, the technical interview(coding+algo questions) will be done by an engineer
Some companies will give you homework, or use a synchronized code writing, or on paper and say it over phone, 
Relative Comparisons=You are being compared with the other interviewees, if the problem is hard for you, it is hard for them- its ok to get wrong
After interview if you don't hear back in 3-5 business days, check in politely with your interviewer in a week, or HR-they might be busy
If you fail an interview most will let you apply again in 6-12 months
Normally 3-6 interviews before an offer
Often your interview goes to a hiring commitee with your interviewers feedback where they will decide 'offer' 'more interviews' or 'rejectsean'
Be nice to your interviewer, they can fight for you to be hired or not
Explain your passion for technology, prepare answer, "Why do you want to work for us?" -Mention VS Code for Microsoft, etc
You will only reach the hiring manager if you've done well
Feedback is typically broken down into four categories (Analytical Ability, Coding,  Experience, and Communication) and you are given an 
  overall score from 1.0 to 4.0
If the hiring committee recommends an offer, your packet will go to a compensation committee and then to the executive management committee. 
  Returning a decision can take several weeks because there are so many stages and committees. 

III-Special Situations-Page 27-37 =========================================================================================================
SDETs =(software design engineers in test), PM=Product Manager ,Dev Lead and Managers
Visas and Work Authorization =Unfortunately, many smaller startups in the U.S. are not able to sponsor work visas. 
People without computer science degrees (or who earned their degrees a long time ago) should focus first on learning the core concepts discussed in this book,
  especially big O time, , binary search tree, breadth-first search, and other important concepts.
Most won't remember Dijkstra's algorithm or the specifics of how AVL trees works. 
Many candidates are poor at articulating their specific accomplishments. 
Not describing the details of the actions they took makes them a flawed candidate, but not necessarily a flawed employee. 
Being a good interview candidate is its own skill
At a very, very high level, there are four modes of questions;
  Sanity Check: These are often easy problem-solving or design questions. They assess a minimum 
    degree of competence in problem-solving. They won't tell distinguish between "okay" versus "great" so 
    don't evaluate them as such. You can use them earfy in the process (to filter out the worst candidates), or 
    when you only need a minimum degree of competency.
  Quality Check: These are the more challenging questions, often in problem-solving or design. They 
    are designed to be rigorous and really make a candidate think. Use these when algorithmic/problemsolving skiils are of high importance. 
    The biggest mistake people make here is asking questions that are, in fact, bad problem-solving questions. 
  Specialist Questions: These questions test knowledge of specific topics, such as Java or machine learning. . If it's easily acquirable,
    then there's no reason to hire for it.
  Proxy Knowledge: This is knowledge that is not quite at the specialist level (in fact, you might not even 
    need it), but that you would expect a candidate at their level to know For example, it might not be very 
    important to you if a candidate knows CSS or HTML. But if a candidate has worked in depth with these 
    technologies and can't talk about why tables are or aren't good, that suggests an issue. They're not 
    absorbing information core to their job.

IV-Before the Interview 38-43 =========================================================================================================
Without a great resume, there's no interview. And without great experience, there's no great resume.
Take the Big Project Classes: Seek out the classes with big coding projects. This is a great way to get somewhat practical experience before you have any 
  formal work experience. The more relevant the project is to the real world, the better. 
Get an Internship: Do everything you can to land an internship early in school. It will pave the way for even better internships before you graduate
Start Something: Build a project on your own time, participate in hackathons, or contribute to an open source project.
  It doesn't matter too much what it is. The important thing is that you're coding.
If you're trying to move from a lesser-known company to one of the "biggies," or from testing/IT into a dev role:
  Shift Work Responsibilities More Towards Coding: Without revealing to your manager that you are thinking  of leaving, you can discuss your eagerness to
    take on bigger coding challenges. As much as possible, try to ensure that these projects are "meaty," use relevant technologies, and lend themselves well
    to a resume bullet or two. It is these coding projects that will, ideally, form the bulk of your resume,
  Use Your Nights and Weekends: If you have some free time, use it to build a mobile app, a web app, or a piece of desktop software
Resume screeners look for the same things that interviewers do. They want to know that you're smart and that you can code.
  That means you should prepare your resume to highlight those two things
In the US, it is strongly advised to keep a resume to one page if you have less than ten years of experience. Shorter resumes are often more impressive. 
Recruiters only spend a fixed amount of time (about 10 seconds) looking at your resume. If you limit the content to the most impressive items, the 
  recruiter is sure to see them. Adding additional items just distracts the recruiter from what you'd really like them to see,
  Some people just flat-out refuse to read long resumes
Employment History: Your resume does not—and should not—include a full history of every role you've ever had. Include only the relevant positions—the 
  ones that make you a more impressive candidate.
Writing Strong Bullets:
  For each role, try to discuss your accomplishments with the following approach:"Accomplished X by implementing Y which led to Z." 
  "Reduced object rendering time by 75% by implementing distributed caching, leading to a 10% reduction in log-in time.
  "Increased average match accuracy from 1.2 to 1.5 by implementing a new comparison algorithm based on windiff."
  Not everything you did will fit intothis approach, butthe principle is the same: show what you did, how you did it, and what the results were.
    Ideally, you should try to make the results "measurable" somehow. 
Developing the projects section on your resume is often the best way to present yourself as more experienced
The projects should include your 2 - 4 most significant projects. State what the project was and which languages or technologies it employed
Be conservative about what software you list, and understand what's appropriate for the company. Software like Microsoft Office can almost always be cut.
  Technical software like Visual Studio and Eclipse is somewhat more relevant, but many of the top tech companies won't even care about that.
Languages: Should you list everything you've ever worked with, or shorten the list to just the ones that you're most comfortable with? 
  Listing everything you've ever worked with is dangerous. Many interviewers consider anything on your resume to be "fair game"as far as the interview.
  One alternative is to list most of the languages you've used, but add your experience level. This approach is shown below:
  Languages: Java (expert), C++ (proficient), JavaScript (prior experience). 
  Use whatever wording ("expert" "fluent" etc.) effectively communicates your skillset. 
  Some people list the number of years of experience they have with a particular language, but this can be really confusing. 
  If you first learned Java 10 years ago, and have used it occasionally throughout that time, how many years of experience is this?
  Some companies will throw out your resume just because of a typo.
For US positions, do not include age, marital status, or nationality. This sort of personal information is not appreciated by companies, as it creates 
  a legal liability for them. Vs Affirmative AxSean
Certifications: Certifications for software engineers can be anything from a positive, to a neutral, to a negative. This goes hand-in-hand with being too
  language focused; the companies that are biased against candidates with a very lengthy list of technologies tend to also be biased against certifications. 
  This means that in some cases, you should actually remove this Sort of experience from your resume. 
The languages in the cluster of {Python, Ruby, and JavaScript) are somewhat similar to each other. It's better if you can learn languages that are more
  different, like Python, C++, and Java. 
Page 42: Interview Prep guide

V-Behavioral Questions 44-49 =========================================================================================================
Behavioral questions are asked to get to know your personality
Go through each of the projects or components of your resume and ensure that you can talk about them in detail. Filling out a grid like this may help: 
  Columns=Challenges, Mistakes/Failures, Enjoyed, Leadership, Conflicts, What you would do differently
  Rows=Common Questions, Project 1, Project 2, Project 3, include any project, job, or activity included on resume
  Study this grid before your interview. Reducing each story to just a couple of keywords may make the grid easier to study and recall.
  you have one to three projects that you can talk about in detail. You should be able to discuss the technical components in depth.
When asked about your weaknesses, give a real weakness! A good answer conveys a real, legitimate weakness but emphasizes how you work to overcome it.
Most interviewers will give you a chance to ask them questions. The quality of your questions will be a factor, in their decisions.
  Genuine Questions: These are the questions you actually want to know the answers to
    "What is the ratio of testers to developers to program managers? What is the interaction like? How does project planning happen on the team?" 
  Insightful Questions: These questions demonstrate your knowledge or understanding of technology.
    "I noticed that you use technology X. How do you handle problem Y?
  Passion Questions: These questions are designed to demonstrate your passion for technology. They show that you're interested in learning and will be a 
    strong contributor to the company
    "I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this company to learn about this?" 
For those projects, and all your projects, be able to talk about the challenges, mistakes, technical decisions, choices of technologies 
  (and tradeoffs of these), and the things you would do differently.
Be Specific, Not Arrogant: Specificity means giving just the facts and letting the interviewer derive an interpretation
Limit Details: Stay tight on details and just state the key points. 
Nugget First: means starting your response with a "nugget" that succinctly describes what your response will be about.
  This technique grabs your interviewer's attention and makes it very ciear what your story will be about
S.A.R. (Situation, Action, Result): you start off outlining the situation, then explaining the actions you took, and lastly, describing the result.
Think about what your story says about you, What personality attributes has the candidate demonstrated?
So, tell me about yourself.... This is essentially a "pitch". It's your interviewer's first impression of you, so you want to be sure to nail this.
  A typical structure that works well for many people is essentially chronological, with the opening sentence describing their current job and the
  conclusion discussing their relevant and interesting hobbies outside of work (if any). 
  Current Role [Headline Only): "I'm a software engineer at Microworks, where I've been leading the Android team for the last five years." 
  College: 
  Post College & Onwards: 
  Current Role (Details): 
  Outside of Work: 
  Wrap Up: Example on page 49
Think carefully about your hobbies. You mayor may not want to discuss them. Often they're just fluff. If your hobby is just generic activities like skiing or 
  playing with your dog, you can probably skip it. Vs hobby is technical. Vs hobby demonstrates a positive personality attribute.
Sprinkle in Shows of Successes: (awards, promotions, being recruited out by someone you worked with, launches, etc.)

VI-BigO 50-71 =========================================================================================================
Big 0 time is the language and metric we use to describe the efficiency of algorithms. 
Time Complexity: This is what the concept of asymptotic runtime, or big 0 time, means.
0(1):0 (big O): In academia, big 0 describes an upper bound on the time. An algorithm that prints all the 
  values in an array could be described asO(N), but it could also be described as OfN^J.O^) , or 0(2 N) (or many other big 0 times). The algorithm is at least
  as fast as each of these; therefore they are upper bounds on the runtime. a simple  algorithm to print the values in an array isO(N) as well asO(M3) or any 
  runtime bigger than 0(N). 
0( log N): The total runtime is then a matter of how many steps (dividing N by 2 each time) we can take until N becomes 1. When you see a problem where the 
number of elements in the problem space gets halved each time, that will likely be a 0(log N) runtime.
0(N log N):
O(N):
O(N^):
0(2^N):
Q (big omega): In academia, 0 is the equivalent concept but for lower bound. Printing the values in an array is fl(N) as well as fi(log M) and Q(l).
After all, you know that it won't be faster than those runtimes. 
0 (big theta): In academia, 0 means both 0 and fi. That is, an algorithm is 0 (N) if it is both 0( N) and 0(N). 0 gives a tight bound on runtime.
You can also have multiple variables in your runtime.
Best Case: If all elements are equal, then quick sort will, on average, just traverse through the array once. This is 0(N).
Worst Case: What if we get really unlucky and the pivot is repeatedly the biggest element in the array? (Actually, this can easily happen. If the pivot is
  chosen to be the first element in the subarray and the array is sorted in reverse order, we'll have this situation.) In this case, our recursion doesn't 
  divide the array in half and recurse on each half. It just shrinks the subarray by one element. This will degenerate to an O(N^) runtime. 
Expected Case: Usually, though, these wonderful or terrible situations won't happen. Sure, sometimes the pivot will be very low or very high, but it won't 
  happen over and over again. We can expect a runtime  of 0( N log N). 
For many—probably most—algorithms, the worst case and the expected case are the same.
We rarely ever discuss best case time complexity, because it's not a very useful concept. After all, we could take essentially any algorithm, special case 
  some input, and then get an 0(1 ) time in the best case. 
Space Complexity: Time is not the only thing that matters in an algorithm. We might also care about the amount of memory— or space—required by an algorithm.
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require 0(n) space. If we need a 
  two-dimensional array of size nxn, this will require 0(n*) space. Stack space in recursive calls counts, too. Each of these calls is added to the call 
  stack and takes up actual memory.
  just because you have n calls total doesn't mean it takes O(n ) space. There will be roughly O(n) calls to pairSum. However, those calls do not exist 
  simultaneously on the call stack, so you only need 0(1) space. 
Drop the Constants: It is very possible for 0(N ) code to run faster than 0(1 ) code for specific inputs.
  For this reason, we drop the constants in runtime. An algorithm that one might have described as 0( 2N) is actuallyO(N).
  accept that it doesn't mean that 0(N) is always better than 0(N^).
Drop the Non-Dominant Terms: 0(N2+ N) becomesO(N^). 0(N2 + N) becomesO(N^).
Multi-Part Algorithms: Add vs. Multiply 
  If your algorithm is in the form "do this, then, when you're all done, do that" then you add the runtimes.
  If your algorithm is in the form "do this for each time you do that" then you multiply the runtimes.
  Count the iterations/runtimes, do they add or multiply?
Amortized Time:  It allows us to describe that, yes, this worst case happens every once in a while. But once it happens, it won't happen again for so 
  long that the cost is "a moritized."
Big 0 time is a difficult concept at first. Once it "clicks," it gets fairly easy. The same patterns come up again and again, and the rest you can derive. 
Examples on page 58-69, Solutions on page 70.

VII-Technical Questions-Page 72-93-=========================================================================================================
Many candidates just read through problems and solutions. That's like trying to learn calculus by reading a problem and its answer. 
You need to practice solving problems. Memorizing solutions won't help you much. 
When you're solving a problem, make sure to think about the space and time efficiency.
Write the code on paper. Coding on a computer offers luxuries such as syntax highlighting, code completion, and quick debugging. Coding on paper does not
Test your code—on paper. This means testing the general cases, base cases, error cases, and so on. You'll need to do this during your interview, 
Type your paper code as-is into a computer. You will probably make a bunch of mistakes. 
  Start a list of all the errors you make so that you can keep these in mind during the actuai interview. 
ost interviewers won't ask about specific algorithms for binary tree balancing or other complex algorithms.they probably don't remember these algorithmseither
BUD(BottleNecks, Unneccesary Work, Duplicated Work) Optimization:
Get a brute-force solution as soon as possible. Don't worry about developing an efficient algorithm yet. State a naive algorithm and its runtime, then 
  optimize from there. Don't code yet though! It's okay and expected that your initial algorithm won't be very optimal. 
Look for any unused info. You usually need all the information in a problem. 
Listen for guidance from the interviewer.The interviewer might take a more active or less active roie in your problem solving. The level of interviewer
  participation depends on your performance, the difficulty of the question, what the interviewer is looking for, and the interviewer's own personality
Listen carefully to the problem, and be sure that you've mentally recorded any *unique* information in the problem. 
When you hear a question, get out of your chair, go to the whiteboard, and draw an example. create an example that is: 
  • Specific. It should use real numbers or strings (if applicable to the problem). 
  • Sufficiently large. Most examples are too small, by about 50%,
  • Not a special case. Be careful, it's very easy to inadvertently draw a special case
Once you have a brute force algorithm, you should work on optimizing it. A few techniques that work well are:
  Look for any unused information. Did your interviewer tell you that the array was sorted? How can you leverage that information? 
  Use a fresh example. Sometimes, just seeing a different example will unclog your mind or help you see a pattern in the problem.
  Make time vs. space tradeoff. Sometimes storing extra state about the problem can help you optimize the runtime.
  Precompute information.Is there a way that you can reorganize the data(sorting, etc) or compute some values upfront that will help save time in the longrun
  Use a hash table. Hash tables are widely used in interview questions and should be at the top of your mind
  Think about the best conceivable runtime (discussed on page 72).
  Walk through the brute force with these ideas in mind and look for BUD (page 67).
Whiteboard coding is slow— So is testing your code and fixing it. you need to make sure that you get it as close to "perfect" in the beginning as possible. 
Implement: Start coding in the far top left corner of the whiteboard (you'll need the space). Avoid "line creep" (where each line of code is written a slant)
Remember that you only have a short amount of code to demonstrate that you're a great developer. Everything counts. Write beautiful code.
Modularized code. This shows good coding style. It also makes things easier for you. don't waste your time writing this initialization code.
  Just pretend you have a function init IncrementalMatrix(int size)
Error checks. Some interviewers care a lot about this, while others don't. 
  A good compromise here is to add a todo and then just explain out loud what you'd like to test.
Good variable names. Code that uses single-letter variables everywhere is difficult to read. Long variable names can also be slow to write though. 
  A good compromise that most interviewers will be okay with is to abbreviate it after the first usage. You can use startChil d the first time, and then 
  explain to your interviewer that you wilt abbreviate this as 'sc' after this.
If you get confused (which is common), go back to your example and walk through it again. 
BUD(BottleNecks, Unneccesary Work, Duplicated Work)=These are three of the most common things that an algorithm can "waste" time doing. 
  Bottlenecks= is a part of your algorithm that slows down the overall runtime. 
  Unnecessary Work=redundant
  Duplicated Work=redundant
If there's only one valid d value for each (a, b, c), then we can just compute it.
We just have to get rid of the first step entirely and operate on an unsorted array. How can we find things quickly in an unsorted array? With a hash table.
Throw everything in thearray into the hash table.to look up if x + k or x - k exist in the array, we just look it up in the hash table. this is 0(N) time. 
Optimize & Solve Technique #2: DIY (Do It Yourself) 
Optimize & Solve Technique #3: Simplify and Generalize=With Simplify and Generalize, we implement a multi-step approach. First, we simplify or tweak some 
  constraint, such as the data type. Then, we solve this new simplified version of the problem. Finally, once we have an algorithm for the simplified 
  problem, we try to adapt it for the more complex version. 
Optimize & Solve Technique #4: Base Case and Build=With Base Case and Build, we solve the problem first for a base case (e.g., n = 1) and then try to buildup 
  from there. When we get to more complex/interesting cases (often n = 3 or n = 4), we try to build those using the prior solutions, 
Optimize & Solve Technique #5: Data Structure Brainstorm = This approach is certainly hacky, but it often works. We can simply run through a list of data
  structures and try to apply each one. This approach is useful because solving a problem may be trivial once it occurs to us to use, say, a tree.
  Linked List? Array? Binary tree? Heap? etc
Best Conceivable Runtime (BCR)=The best conceivable runtime is, literally, the best runtime you could conceive of a solution to a problem
Handling Incorrect Answers=One of the most pervasive—and dangerous—rumors is that candidates need to get every question right. That's not quite true. 
  First, responses to interview questions shouldn't be thought of as "correct" or "incorrect." When I evaluate how someone performed in an interview, 
  I never think, "How many questions did they get right?" It's not a binary evaluation. Rather, it's about how optimal their final solution was,
  how long it took them to get there, how much help they needed, and how clean was their code. There is a range of factors
  Second, your performance is evaluated in comparison to other candidates.
  Third, many—possibly most—questions are too difficult to expect even a strong candidate to immediately spit out the optimal algorithm. The questions I 
  tend to ask would take strong candidates typically 20 to 30 minutes to solve.
When You've Heard a Question Before=If you've heard a question before, admit this to your interviewer. 
If you're given a choice of languages, then you should probably pick whatever language you're most comfortable with. 
Some languages just open you up to potential issues. For example, using C++ means that, in addition to ail the usual bugs you can have in your code, 
  you can have memory management and pointer issues
Broadly speaking, good code has the following properties:
  Correct: The code should operate correctly on all expected and unexpected inputs.
  Efficient: The code should operate as efficiently as possible in terms of both time and space.
    "efficiency" includes both the asymptotic (big 0) efficiency and the practical, real-life efficiency
  Simple: If you can do something in 10 lines instead of 100, you should. Code should be as quick as possible for a developer to write.
  Readable: A different developer should be able to read your code and understand what it does and how it does it. Readable code has comments where 
    necessary, but it implements things in an easily understandable way
  Maintainable: Code should be reasonably adaptable to changes during the life cycle of a product and should be easy to maintain by other developers, 
    as well as the initial developer. 
Use Data Structures Generously 
Appropriate Code Reuse
Modular=Writing modular code means separating isolated chunks of code out into their own methods.This helps keep the code more maintainable, readable, and 
  testable. As code gets more complex, it becomes increasingly important to write it in a modular way. This will make it easier to read and maintain.
Error Checking=One sign of a careful coder is that she doesn't make assumptions about the input. Instead, she validates that the input is what it 
  should be, either through ASSERT statements or if-statements
  writing these error checks can be tedious and can waste precious time in an interview. The important thing is to point out that you would write the checks

VIII-The Offer and Beyond-Page 94-98=========================================================================================================
When companies extend an offer, there's almost always a deadline attached to it. Usually these deadlines are one to four weeks out.
It's in your best interest to decline the offer on good terms and keep a tine of communication open, provide a reason that Is non-offensive and inarguable
Handling Rejection:Thank your recruiter for his time, explain that you're disappointed but that you understand their position, and ask when 
  you can reapply to the company. You can also ask for feedback from the recruiter  It doesn't hurt to ask a question like, "Is there anything you'd 
  suggest I work on for next time?"
Evaluating the Offer: The Financial Package Perhaps the biggest mistake that candidates make in evaluating an offer is looking too much at their salary. 
  Salary is just one part of your financial compensation. Signing Bonus, Relocation, and Other One Time Perks: Cost of Living Difference: 
  Annual Bonus: Annual bonuses at tech companies can range from anywhere from 3% to 30%
  Stock Options and Grants: Equity compensation can form another big part of your annual compensation. Like signing bonuses, stock compensation between
  companies can be compared by amortizing it over three years and then lumping that value into salary. 
  important that you think right now about how this offer would impact your career path. How good does the company's name look on my resume?
  How much will I learn? Will I learn relevant things? What is the promotion plan? How do the careers of developers progress? 
  If I do want to leave the company, is it situated near other companies I'm interested in, or will I need to move?
  Manager and Tea mm ates: When people say that they love, or hate, their job, it's often because of their teammates and their manager. 
  Company Culture: Culture is tied to everything from how decisions get made, to the social atmosphere, to how the company is organized. Ask your future 
      teammates how they would describe the culture
  Hours: Ask future teammates about how long they typically work, and figure out if that meshes with your lifestyle.
    Remember, though, that hours before major deadlines are typically much longer
  Negotiation: isn't fun for most of us. But still, the financial benefits of negotiation are usually worth it. Recruiters will not revoke an offer
    because you negotiated, so you have little to lose. Have a Viable Alternative. Fundamentally, recruiters negotiate with you because they're concerned you 
    may not join the company otherwise. If you have alternative options, that will make their concern much more real.
    Have a Specific "Ask": It's more effective to ask for an additional $7000 in salary than to just ask for "more." Overshoot: In negotiations, people
    usually don't agree to whatever you demand. It's a back and forth conversation. Ask for a bit more than you're reaily hoping to get, since the company 
    will probably meet you in the middle. Think Beyond Salary: Companies are often more willing to negotiate on non-salary components, since boosting your
    salary too much could mean that they're paying you more than your peers. Consider asking for more equity or a bigger signing bonus. Alternatively,
    you may be able to ask for your relocation benefits in cash, instead of having the company pay directly for the moving
    Use Your Best Medium: Many people will advise you to only negotiate over the phone. To a certain extent, they're right; it is better to negotiate over
    the phone. However, if you don't feel comfortable on a phone negotiation, do it via email.
  Set a Timeline:When you're enjoying your job, it's very easy to get wrapped up in it and not realize that your career is not advancing. 
  Build Strong Relationships: When you want to move on to something new, your network will be critical. After all, applying online is tricky; a personal 
    referral is much better, and your ability to do so hinges on your network. At work, establish strong relationships with your manager and teammates. When
    employees leave, keep in touch with them. Just a friendly note a few weeks after their departure will help to bridge that connection 
    from a work acquaintance to a personal acquaintance. This same approach applies to your persona/ life. Your friends, and your friends of friends, are
    valuable connections. Be open to helping others, and they'll be more likely to help you.
  Ask for What You Want: While some managers may really try to grow your career, others will take a more hands-off approach. It's up to you to pursue the
    challenges that are right for your career. Be (reasonably) frank about your goals with your manager. If you want to take on more back-end coding, say so. 
  Keep Interviewing: Set a goal of interviewing at least once a year, even if you aren't actively looking for a new job. This will keep your interview skills
    fresh, and also keep you in tune with what sorts of opportunities (and salaries) are out there.

IX-Interview Questions-Page 99-=========================================================================================================
  pg100-103 Arrays and Strings
  pg104-107 Linked Lists 
  pg108-111 Stacks and Queues 
  pg112-123 Trees and Graphs
  pg124-128 Bit Manipulation
  pg129-136 Math and Logic Puzzles
  pg137-141 Object-Oriented Design 
  pg142-148 Recursion and Dynamic Programming 
  pg149-157 System Design and Scalability 
  pg158-163 Sorting and Searching
  pg164-169 Testing
  pg170-176 C & C++
  pg177-180 Java
  pg181-185 Databases
  pg186-192 Threads and Locks
  pg193-197 Moderate Questions
  pg198-202 Hard Questions
  pg203 Solutions
    pg204-219 Solutions to Arrays and Strings
    pg220-238 Solutions to Linked Lists
    pg239-252 Solutions to Stacks and Queues
    pg253-287 Solutions to Trees and Graphs
hash table= is a data structure that maps keys to values for highly efficient lookup. There are a number of ways of implementing this.
     we can implement the hash table with a balanced binary search tree.This gives us an 0 (log N) lookup time. The advantage of this is potentially using 
     less space, since we no longer allocate a large array. 
Be sure you are comfortable with dynamically resizable arrays/lists in whatever language you will be working with.
linked list= is a data structure that represents a sequence of nodes. In a singly linked list, each node points to the next node in the linked list. A 
doubly linked= list gives each node pointers to both the next node and the previous node.
  Unlike an array, a linked list does not provide constant time access to a particular "index" within the list
  this means that if you'd like to find the Kth element in the list, you will need to iterate through K elements.
The stack data structure is precisely what it sounds like: a stack of data, it can be favorable to store data in a stack rather than in an array. A stack uses
  LIFO (last-in first-out) ordering. That is, as in a stack of dinner plates, the most recent item added to the stack is the first item to be removed.
  • pop(): Remove the top item from the stack. 
  • push( item) : Add an item to the top of the stack. 
  • peek ( ): Return the top of the stack. 
  • isEmpty() : Return true if and only if the stack is empty
queue= implements FIFO (first-in first-out) ordering. As in a ticket stand, items are removed from the data structure in the same order that they are added
  One place where queues are often used is in breadth-first search or in implementing a cache
A tree=is a data structure composed of nodes, Each tree has a root node, The root node has zero or more child nodes, each child may have nodes, etc
A node is called a "leaf" node if it has no children.
Binary Tree Traversal Prior to your interview, you should be comfortable implementing in-order, post-order, and pre-order traversal. 
  The most common of these is in-order traversal.
min-heap=is a complete binary tree (that is, totally filled other than the rightmost elements on the last level) where each node is smaller than its children
  The root, therefore, is the minimum element in the tree, We have two key operations on a min-heap: insert and extract_min .
Max-heaps=are essentially equivalent, but the elements are in descending order rather than ascending order, 
A trie (sometimes called a prefix tree) is a funny data structure. A trie is a variant of an n-arytree in which characters are stored at each node. Each
  path down the tree may represent a word. Very commonly, a trie is used to store the entire (English) language for quick prefix lookups. While a hash 
  table can quickly look up whether a string is a valid word, it cannot tell us if a string is a prefix of any valid words. A trie can do this very quickly. 
A tree is actually a type of graph, but not all graphs are trees, a tree is a connected graph without cycles.
A graph is simply a collection of nodes with edges between (some of) them.
  Graphs can be either directed (like the following graph) or undirected. directed edges are like a one-way street, undirected edges are like a two-way street
Adjacency List=This is the most common way to represent a graph. Every vertex (or node] stores a list of adjacent vertices. Adjacency Matrices 
Graph Search The two most common ways to search a graph are depth-first search and breadth-first search
depth-first search (DFS),= we start at the root (or another arbitrarily selected node) and explore each branch completely before moving on to the next branch.
  That is, we go deep first (hence the name depthfirst search) before we go wide. DFS is often preferred if we want to visit every node in the graph.
breadth-first search (BFS),= we start at the root (or another arbitrarily selected node) and explore each neighbor before going on to any of their children.
  That is, we go wide (hence breadth-first search) before we go deep. , if we want to find the shortest path between two nodes, BFS is generally better. 
Bidirectional search=is used to find the shortest path between a source and destination node. It operates by essentially running two simultaneous
  breadth-first searches, one from each node. When their searches collide, we have found a path.
So-called "puzzles"(or brain teasers) are some of the most hotly debated questions, and many companies have policies banning them
Generating a List of Primes: The Sieve of Eratosthenes=It works by recognizing that ail non-prime numbers are divisible by a prime number.
  We start with a list of all the numbers up through some value max. First, we cross off alt numbers divisible by 2. Then, we look for the next prime 
  (the next non-crossed off number) and cross off alt numbers divisible by it. By crossing off alt numbers divisible by 2, 3, 5, 7,11, and so on, we wind
  up with a list of prime numbers from 2 through max. 
Many people, strangely, mix up the concepts of independence and mutual exclusivity. They are entirely different. In fact,
  two events cannot be both independent and mutually exclusive. mutual exclusivity means that if one happens then the other cannot. 
  Independence, however, says that one event happening means absolutely nothing about the other event.
interviewers want to see how you tackle a problem; Start talking, and show the interviewer how you approach a problem. 
In many cases, you will find it useful to write down 'ruies"or patterns that you discover white solving the problem. And yes, you really should write 
  these down—it will help you remember them as you solve the problem.
Many brainteasers are worst-case minimization problems, worded either in terms of minimizing an action or reducing the amount of times you do an action
Object-oriented design questions require a candidate to sketch out the classes and methods to implement technical problems or real-life objects. 
  These problems give—or at least are believed to give— an interviewer insight into your coding style. These questions are not so much about regurgitating 
  design patterns as they are about demonstrating that you understand how to create elegant, maintainable object-oriented code
  Step 1; Handle Ambiguity: (OOD) questions are often intentionally vague in order to test if you'll make assumptions or if you'll ask clarifying questions.
    inquire who is going to use it and how they are going to use it. "six Ws"; who, what, where, when, how, why.
  Step 2: Define the Core Objects: object-oriented design for a restaurant. Our core objects might be things like 
    Table, Guest, Party , Order, Meal, Employee, Server, and Host, 
  Step 3: Analyze Relationships: Which objects are members of which other objects? Do any objects inherit from any others? Are relationships 
    many-to-many or one-to-many?
  Step 4: Investigate Actions: you should have the basic outline of your object-oriented design. What remains is to consider the key actions that the 
    objects will take and how they relate to each other
Singleton Class=ensures that a class has only one instance and ensures access to the instance through the application. 
  "global" object with exactly one instance
Factory Method=interface for creating an instance of a class, with its subclasses deciding which class to instantiate.
A good hint that a problem is recursive is that it can be built off of subproblems. Recursive solutions, by definition, 
  are built off of solutions to subproblems
Three of the most common approaches to develop an algorithm are bottom-up, top-down, and half-and-half.
  The bottom-up approach is often the most intuitive. We start with knowing how to solve the problem for a simple case, Then we figure out how to solve the 
    problem for two elements, then for three elements, and so on.
  The top-down approach In these problems, we think about how we can divide the problem for case N into subproblems.
  Half-and-Half Approach, binary search works with a "ha!f-and-half"approach. Merge sort is also a "half-and-half" approach
Recursive algorithms can be very space inefficient. Each recursive call adds a new layer to the stack, which means that if your algorithm recurses to a 
  depth of n, it uses at least 0(n) memory. it's often better to implement a recursive algorithm iteratively. All recursive algorithms can be implemented
    iteratively, although sometimes the code to do so is much more complex. 
Dynamic programming is mostly just a matter of taking a recursive algorithm and finding the overlapping subproblems (that is, the repeated calls). You then
  cache those results for future recursive calls. 
Alternatively, you can study the pattern of the recursive calls and implement something iterative.
Tip: Remember this for future problems. Drawing the recursive calls as a tree is a great way to figure out the runtime of a recursive algorithm
memoization=Each time we compute f ib ( i) , we should just cache this result and use it later. 
Despite how intimidating they seem, scalability questions can be among the easiest questions.
 Tackle the problem by doing it just like you would at work. Ask questions. Engage the interviewer. Discuss the tradeoffs.
Communicate: A key goal of system design questions is to evaluate your ability to communicate. Stay 
engaged with the interviewer. Ask them questions. Be open about the issues of your system, 
• Go broad first: Don't dive straight into the algorithm part or get excessively focused on one part. 
• Use the whiteboard: Using a whiteboard helps your interviewerfollow your proposed design. Get up to 
the whiteboard in the very beginning and use it to draw a picture of what you're proposing. 
• Acknowledge interviewer concerns: Your interviewer will likely jump in with concerns. Don't brush 
them off; validate them. Acknowledge the issues your interviewer points out and make changes accordingly. 
• Be careful about assumptions: An incorrect assumption can dramatically change the problem. For 
example, if your system produces analytics / statistics for a dataset, it matters whether those analytics 
must be totally up to date. 
• State your assumptions explicitly: When you do make assumptions, state them.This allows your interviewer to correct you if you're mistaken, and shows 
  that you at least know what assumptions you're making. 
• Estimate when necessary: In many cases, you might not have the data you need. For example, if you're 
designing a web crawler, you might need to estimate how much space it will take to store all the URLs. 
You can estimate this with other data you know. 
• Drive: As the candidate, you should stay in the driver's seat. This doesn't mean you don't talk to your 
interviewer; in fact, you musrtalkto your interviewer. However, you should be driving through the ques
Ask questions. Be open about tradeoffs. Continue to go deeper. Continue to make improvements. 
Step 1:Scope the Problem:You can't design a system if you don't know what you're designing. 
Step 2: Make Reasonable Assumptions
Step 3: Draw the Major Components(whiteboard)
Step 4; Identify the Key Issues Once you have a basic design in mind. Focus on the key issues. What will be the bottlenecks or major challenges in the system?
Step 5: Redesign for the Key Issues: Once you have identified the key issues, it's time to adjust your design for it. You might find that it involves 
  a major redesign or just some minor tweaking (like using a cache). Be open about any limitations in your design. Your interviewer will likely be aware of 
  them, so it's important to communicate that you're aware of them, too

Algorithms that Scale: Step-By-Step: In some cases, you're not being asked to design an entire system. You're just being asked to design a single 
  feature or algorithm, but you have to do it in a scalable way
Step 1: Ask Questions: ask questions to make sure you really understand the question. There might be details the interviewer left out
Step 2; Make Believe: Pretend that the data can all fit on one machine and there are no memory limitations. How would you solve 
  the problem? The answer to this question will provide the general outline for your solution. 
Step 3: Get Real: Now go back to the original problem. How much data can you fit on one machine, and what problems will occur when you split up the data? 
Step 4: Solve Problems: Finally, think about how to solve the issues you identified in Step 2. Remember that the solution for each 
  issue might be to actually remove the issue entirely, or it might be to simply mitigate the issue. 
Your goal is not to re-architect a complex system that companies have spent millions of dollars building, but rather to demonstrate that you can analyze 
  and solve problems, Poking holes in your own solution is a fantastic way to demonstrate this. 
A system can be scaled one of two ways: Vertical scaling means increasing the resources of a specific node, increasing memory on a machine
  Horizontal scaling means increasing the number of nodes. For example, you might add additional servers
Vertical scaling is generally easier than horizontal scaling, but it's limited. You can only add so much memory or disk space. 
Load Balancer: allows a system to distribute the load evenly so that one server doesn't crash and take down the whole system. 
Database Denormalization and NoSQL: Joins in a relational database such as SQL can get very slow as the system grows bigger. For this reason, you would
  generally avoid them.  Denormalization means adding redundant information into a database to speed up reads.
A NoSQL database does not support joins and might structure data in a different way. It is designed to scale better. 
Database Partitioning (Sharding): means splitting the data across multiple machines while ensuring you have a way of figuring out which data is on which PC
Vertical Partitioning: This is basically partitioning by feature. For example, if you were building a social network, you might have one partition for
  tables relating to profiles, another one for messages,
Key-Based (or Hash-Based) Partitioning: This uses some part of the data 
Directory-Based Partitioning: In this scheme, you maintain a lookup table for where the data can be found. 
Caching An in-memory cache can deliver very rapid results. It is a simple key-value pairing and typically sits between your application layer and data store. 
Slow operations should ideally be done asynchronously
Networking Metrics:
  Bandwidth: This is the maximum amount of data that can be transferred in a unit of time. It is typically expressed in bits per second
  Throughput: Whereas bandwidth is the maximum data that can be transferred in a unit of time, throughput is the actual amount of data that is transferred.
  Latency:This is how long it takes data to go from one end to the other. That is, it is the delay between the sender sending information and receiving it
MapReduce=program is typically used to process large amounts of data. requires you to write a Map step and a Reduce step
Understanding the common sorting and searching algorithms is incredibly valuable, as many sorting and searching problems are tweaks of well-known algorithms
  Bubble Sort=, we start at the beginning of the array and swap the first two elements if the first is greater than the second.
  Selection Sort=inefficient. Find the smallest element using a linear scan and move it to the front (swapping it with the front element). Then, find the
    second smallest and move it, again doing a linear scan.
  Merge Sort=Merge sort divides the array in half, sorts each of those halves, and then merges them back together
  Quicksort=we pick a random element and partition the array, such that all numbers that are iess than the partitioning element come before all elements
    that are greater than it.
  Radix Sort=In radix sort, we iterate through each digit of the number, grouping numbers by each digit.
Searching Algorithms:
 binary search=we look for an element x in a sorted array by first comparing x to the midpoint of the array. 
  If x is less than the midpoint, then we search the left half of the array. If x is greater than the midpoint, then we search the right half of the array.
  We then repeat this process, treating the left and right halves as subarrays. Again, we compare x to the midpoint of this subarray and then search either
  its left or right side. We repeat this process until we either find x or the subarray has size 0.
Big Picture Understanding: Are you a person who understands what the software is really about? Can you prioritize test cases properly?
Knowing How the Pieces Fit Together: Do you understand how software works, and how it might fit into a greater ecosystem?
Organization: Do you approach the problem in a structured manner, or do you just spout off anything that comes to your head?
Practicality: Can you actually create reasonable testing plans?
Step 1: Who will use it? And why?
Step 2: What are the use cases?
Step 3: What are the bounds of use? 
Step 4: What are the stress / failure conditions?
Step 5: How would you perform the testing? 
Black Box Testing vs. White Box Testing:  In black box testing, we're just given the software as-ts and need to test it. With white box 
  testing, we have additional programmatic access to test individual functions
Breakdown your testing into the main components, and go from there
Step 1; Define the test cases
  The normal case; Does it generate the correct output for typical inputs?
  The extremes: What happens when you pass in an empty array? Or a very small (one element) array? What if you pass in a very large one?
  Nulls and "illegal"input: 
  Strange input; A fourth kind of input sometimes comes up; strange input
Step 2: Define the expected result
Step 3: Write test code
A final type of question is explaining how you would debug or troubleshoot an existing issue. 
Step 1: Understand the Scenario= first thing you should do is ask questions to understand as much about the situation as possible
Step 2: Break Down the Problem 
Step 3: Create Specific, Manageable Tests
If you don't remember all the APIs, don't worry—most interviewers (though not ail) don't care that much. We do recommend, however, studying up 
  on basic C++ syntax so that you can approach these questions with ease
Templates are a way of reusing code to apply the same class to different data types
A pointer holds the address of a variable and can be used to perform any operation that could be directly done on the variable, such as accessing/modifying it 
A reference is another name (an alias) for a pre-existing object and it does not have memory of its own
Java:
  Overloading is a term used to describe when two methods have the same name but differ in the type or number of arguments, 
  Overriding, however, occurs when a method shares the same name and function signature as another method in its super clas 
Java's collection framework is incredibly useful, and you will see it used throughout this book. Here are some of the most useful items: 
  ArrayList : An Arra y Lis t is a dynamically resizing array, which grows as you insert elements. 
  Vector: A vecto r is very similar to an ArrayList , except that it is synchronized. Its syntax is almost identical as well.
  LinkedList : Linked Lis t is, of course, Java's built-in Linked Lis t class. Though it rarely comes up in an interview
  HashMap:TheHashMap collection is widely used, both in interviews and in the real world. We've provided a snippet of the syntax below. 
    1 HashMap<String, String> map = new HashMap<Stringj String>(); 
    2 map.put("one", "uno"); 
    3 map.putC'two", "dos"); 
    4 System.out.print In(map.get("one")); 
Normalized databases are designed to minimize redundancy, while denormalized databases are designed to optimize read time. 
Small Database Design : you might be asked to design your own database. We'll walk you through an approach
  Step 1: Handle Ambiguity=Before you proceed with your design, you must understand exactly what you need to design. 
  Step 2: Define the Core Objects=Each of these core objects typically translates into a table. 
  Step 3: Analyze Relationships
  Step 4: Investigate Actions
When designing a large, scalable database, joins (which are required in the above examples) are generally very slow. Thus, you must denormalize your data
Every thread in Java is created and controlled by a unique object of the java , lang . Thread class When a standalone application is run, a user thread is 
  automatically created to execute the main () method.
In Java, we can implement threads in one of two ways: 
• By implementing the j ava . lang , Runnable interface 
• By extending the java . lang . Thread class 
Threads within a given process share the same memory space, which is both a positive and a negative. It enables threads to share data, which can be valuable. 
  However, it also creates the opportunity for issues when two threads modify a resource at the same time.
A lock (or monitor)= is used to synchronize access to a shared resource by associating the resource with the lock
A deadlock= is a situation where a thread is waiting for an object lock that another thread holds, and this second thread is waiting for an object lock that the 
  first thread holds Since each thread is waiting for the other thread to relinquish a lock, they both remain waiting forever.
In order for a deadlock to occur, you must have all four of the following conditions met: 
  Mutual Exclusion: Only one process can access a resource at a given time
  Hold and Wait: Processes already holding a resource can request additional resources, without relinquishing their current resources
  No Preemption:One process cannot forcibly remove another process'resource. 
  Circular lVa/f;Two or more processes form a circular chain where each process is waiting on another resource in the chain. 








































